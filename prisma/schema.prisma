// CashFlow AI - Prisma Schema
// PostgreSQL 15 with TimescaleDB extension
// Generated by Genesis Pipeline Stage 2 (DESIGN)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// ENUMS
// =============================================================================

enum UserRole {
  admin
  cfo
  controller
  analyst
  viewer
}

enum Industry {
  manufacturing
  professional_services
  saas
  retail
  other
}

enum SubscriptionTier {
  starter
  professional
  enterprise
}

enum SubscriptionStatus {
  trial
  active
  past_due
  cancelled
}

enum AccountType {
  checking
  savings
  credit
  investment
  other
}

enum PaymentChannel {
  online
  in_store
  other
}

enum TransactionType {
  inflow
  outflow
  transfer
}

enum RecurringPattern {
  weekly
  biweekly
  monthly
  quarterly
  annual
}

enum ForecastScenario {
  pessimistic
  baseline
  optimistic
}

enum ForecastTriggerType {
  manual
  scheduled
  webhook
}

enum ForecastStatus {
  pending
  processing
  completed
  failed
}

enum AlertType {
  cash_shortage
  late_payment_risk
  anomaly
  working_capital
  forecast_deviation
}

enum AlertSeverity {
  info
  warning
  critical
}

enum AlertStatus {
  active
  acknowledged
  resolved
  dismissed
}

enum IntegrationProvider {
  plaid
  quickbooks
  netsuite
  sage_intacct
  stripe
  bill_com
}

enum IntegrationStatus {
  pending
  connected
  error
  disconnected
}

enum InvoiceSource {
  quickbooks
  netsuite
  sage_intacct
  manual
}

enum InvoiceType {
  receivable
  payable
}

enum InvoiceStatus {
  draft
  sent
  partial
  paid
  overdue
  void
}

// =============================================================================
// CORE MODELS
// =============================================================================

model User {
  id            String    @id @default(uuid()) @db.Uuid
  email         String    @unique @db.VarChar(255)
  passwordHash  String    @map("password_hash") @db.VarChar(255)
  firstName     String    @map("first_name") @db.VarChar(100)
  lastName      String    @map("last_name") @db.VarChar(100)
  role          UserRole  @default(analyst)
  companyId     String    @map("company_id") @db.Uuid
  mfaEnabled    Boolean   @default(false) @map("mfa_enabled")
  mfaSecret     String?   @map("mfa_secret") @db.VarChar(255)
  lastLoginAt   DateTime? @map("last_login_at") @db.Timestamptz()
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz()

  // Relations
  company             Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  acknowledgedAlerts  Alert[]        @relation("AlertAcknowledgedBy")
  triggeredForecasts  ForecastRun[]  @relation("ForecastTriggeredBy")
  auditLogs           AuditLog[]

  @@index([companyId])
  @@index([email])
  @@map("users")
}

model Company {
  id                 String             @id @default(uuid()) @db.Uuid
  name               String             @db.VarChar(255)
  industry           Industry
  employeeCount      Int                @map("employee_count")
  annualRevenue      BigInt             @map("annual_revenue") // in cents
  timezone           String             @default("America/New_York") @db.VarChar(50)
  currency           String             @default("USD") @db.VarChar(3)
  subscriptionTier   SubscriptionTier   @default(starter) @map("subscription_tier")
  subscriptionStatus SubscriptionStatus @default(trial) @map("subscription_status")
  stripeCustomerId   String?            @map("stripe_customer_id") @db.VarChar(255)
  createdAt          DateTime           @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt          DateTime           @updatedAt @map("updated_at") @db.Timestamptz()

  // Relations
  users                 User[]
  bankAccounts          BankAccount[]
  transactions          Transaction[]
  forecasts             Forecast[]
  forecastRuns          ForecastRun[]
  alerts                Alert[]
  integrations          Integration[]
  invoices              Invoice[]
  workingCapitalMetrics WorkingCapitalMetric[]
  auditLogs             AuditLog[]

  @@index([industry])
  @@index([subscriptionStatus])
  @@map("companies")
}

// =============================================================================
// BANKING & TRANSACTIONS
// =============================================================================

model BankAccount {
  id               String      @id @default(uuid()) @db.Uuid
  companyId        String      @map("company_id") @db.Uuid
  plaidAccountId   String      @unique @map("plaid_account_id") @db.VarChar(255)
  plaidAccessToken String      @map("plaid_access_token") @db.VarChar(255) // encrypted
  institutionName  String      @map("institution_name") @db.VarChar(255)
  institutionId    String      @map("institution_id") @db.VarChar(100)
  accountName      String      @map("account_name") @db.VarChar(255)
  accountType      AccountType @map("account_type")
  accountSubtype   String?     @map("account_subtype") @db.VarChar(50)
  mask             String?     @db.VarChar(4) // last 4 digits
  currentBalance   BigInt      @default(0) @map("current_balance") // in cents
  availableBalance BigInt      @default(0) @map("available_balance") // in cents
  currency         String      @default("USD") @db.VarChar(3)
  isActive         Boolean     @default(true) @map("is_active")
  lastSyncedAt     DateTime?   @map("last_synced_at") @db.Timestamptz()
  createdAt        DateTime    @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt        DateTime    @updatedAt @map("updated_at") @db.Timestamptz()

  // Relations
  company      Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@index([companyId])
  @@index([institutionId])
  @@map("bank_accounts")
}

// Note: This table will be converted to a TimescaleDB hypertable after migration
// Run: SELECT create_hypertable('transactions', by_range('transaction_date', INTERVAL '1 month'));
model Transaction {
  id                 String           @id @default(uuid()) @db.Uuid
  bankAccountId      String           @map("bank_account_id") @db.Uuid
  companyId          String           @map("company_id") @db.Uuid
  plaidTransactionId String           @map("plaid_transaction_id") @db.VarChar(255)
  transactionDate    DateTime         @map("transaction_date") @db.Timestamptz()
  amount             BigInt           // in cents, negative = outflow
  categoryPrimary    String?          @map("category_primary") @db.VarChar(100)
  categoryDetailed   String?          @map("category_detailed") @db.VarChar(100)
  merchantName       String?          @map("merchant_name") @db.VarChar(255)
  description        String?          @db.Text
  pending            Boolean          @default(false)
  paymentChannel     PaymentChannel?  @map("payment_channel")
  transactionType    TransactionType? @map("transaction_type")
  isRecurring        Boolean          @default(false) @map("is_recurring")
  recurringPattern   RecurringPattern? @map("recurring_pattern")
  createdAt          DateTime         @default(now()) @map("created_at") @db.Timestamptz()

  // Relations
  bankAccount BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  company     Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([plaidTransactionId])
  @@index([companyId, transactionDate(sort: Desc)])
  @@index([bankAccountId, transactionDate(sort: Desc)])
  @@index([categoryPrimary])
  @@map("transactions")
}

// =============================================================================
// FORECASTING
// =============================================================================

model ForecastRun {
  id                 String              @id @default(uuid()) @db.Uuid
  companyId          String              @map("company_id") @db.Uuid
  triggeredBy        String?             @map("triggered_by") @db.Uuid
  triggerType        ForecastTriggerType @map("trigger_type")
  status             ForecastStatus      @default(pending)
  modelVersion       String              @map("model_version") @db.VarChar(50)
  accuracyMetrics    Json?               @map("accuracy_metrics") // MAPE, RMSE, MAE
  dataRangeStart     DateTime            @map("data_range_start") @db.Timestamptz()
  dataRangeEnd       DateTime            @map("data_range_end") @db.Timestamptz()
  forecastHorizonDays Int                @default(90) @map("forecast_horizon_days")
  processingTimeMs   Int?                @map("processing_time_ms")
  errorMessage       String?             @map("error_message") @db.Text
  createdAt          DateTime            @default(now()) @map("created_at") @db.Timestamptz()
  completedAt        DateTime?           @map("completed_at") @db.Timestamptz()

  // Relations
  company   Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  triggerer User?      @relation("ForecastTriggeredBy", fields: [triggeredBy], references: [id])
  forecasts Forecast[]

  @@index([companyId, createdAt(sort: Desc)])
  @@map("forecast_runs")
}

// Note: This table will be converted to a TimescaleDB hypertable after migration
// Run: SELECT create_hypertable('forecasts', by_range('forecast_date', INTERVAL '3 months'));
model Forecast {
  id               String           @id @default(uuid()) @db.Uuid
  companyId        String           @map("company_id") @db.Uuid
  forecastRunId    String           @map("forecast_run_id") @db.Uuid
  forecastDate     DateTime         @map("forecast_date") @db.Timestamptz()
  predictedBalance BigInt           @map("predicted_balance") // in cents
  predictedInflow  BigInt           @map("predicted_inflow") // in cents
  predictedOutflow BigInt           @map("predicted_outflow") // in cents
  confidenceLower  BigInt           @map("confidence_lower") // in cents
  confidenceUpper  BigInt           @map("confidence_upper") // in cents
  confidenceLevel  Decimal          @default(0.95) @map("confidence_level") @db.Decimal(5, 4)
  scenario         ForecastScenario @default(baseline)
  modelVersion     String           @map("model_version") @db.VarChar(50)
  createdAt        DateTime         @default(now()) @map("created_at") @db.Timestamptz()

  // Relations
  company     Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  forecastRun ForecastRun @relation(fields: [forecastRunId], references: [id], onDelete: Cascade)

  @@index([companyId, forecastDate(sort: Desc)])
  @@index([forecastRunId])
  @@index([companyId, scenario, forecastDate(sort: Desc)])
  @@map("forecasts")
}

// =============================================================================
// ALERTS
// =============================================================================

model Alert {
  id              String        @id @default(uuid()) @db.Uuid
  companyId       String        @map("company_id") @db.Uuid
  alertType       AlertType     @map("alert_type")
  severity        AlertSeverity
  title           String        @db.VarChar(255)
  message         String        @db.Text
  metadata        Json?         // context-specific data
  predictedDate   DateTime?     @map("predicted_date") @db.Timestamptz()
  predictedAmount BigInt?       @map("predicted_amount") // in cents
  status          AlertStatus   @default(active)
  acknowledgedBy  String?       @map("acknowledged_by") @db.Uuid
  acknowledgedAt  DateTime?     @map("acknowledged_at") @db.Timestamptz()
  createdAt       DateTime      @default(now()) @map("created_at") @db.Timestamptz()
  expiresAt       DateTime?     @map("expires_at") @db.Timestamptz()

  // Relations
  company      Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  acknowledger User?   @relation("AlertAcknowledgedBy", fields: [acknowledgedBy], references: [id])

  @@index([companyId, status, createdAt(sort: Desc)])
  @@index([severity, status])
  @@index([alertType, status])
  @@map("alerts")
}

// =============================================================================
// INTEGRATIONS
// =============================================================================

model Integration {
  id                   String              @id @default(uuid()) @db.Uuid
  companyId            String              @map("company_id") @db.Uuid
  provider             IntegrationProvider
  status               IntegrationStatus   @default(pending)
  credentials          Json                // encrypted tokens
  settings             Json                @default("{}")
  lastSyncedAt         DateTime?           @map("last_synced_at") @db.Timestamptz()
  syncFrequencyMinutes Int                 @default(60) @map("sync_frequency_minutes")
  errorMessage         String?             @map("error_message") @db.Text
  createdAt            DateTime            @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt            DateTime            @updatedAt @map("updated_at") @db.Timestamptz()

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, provider])
  @@map("integrations")
}

// =============================================================================
// INVOICES (AR/AP)
// =============================================================================

model Invoice {
  id                   String        @id @default(uuid()) @db.Uuid
  companyId            String        @map("company_id") @db.Uuid
  externalId           String        @map("external_id") @db.VarChar(255)
  source               InvoiceSource
  type                 InvoiceType
  customerVendorName   String        @map("customer_vendor_name") @db.VarChar(255)
  amount               BigInt        // in cents
  currency             String        @default("USD") @db.VarChar(3)
  issueDate            DateTime      @map("issue_date") @db.Date
  dueDate              DateTime      @map("due_date") @db.Date
  paidDate             DateTime?     @map("paid_date") @db.Date
  status               InvoiceStatus
  predictedPaymentDate DateTime?     @map("predicted_payment_date") @db.Date
  paymentProbability   Decimal?      @map("payment_probability") @db.Decimal(5, 4)
  createdAt            DateTime      @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt            DateTime      @updatedAt @map("updated_at") @db.Timestamptz()

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, source, externalId])
  @@index([companyId, type, status])
  @@index([dueDate])
  @@map("invoices")
}

// =============================================================================
// WORKING CAPITAL METRICS
// =============================================================================

// Note: This table will be converted to a TimescaleDB hypertable after migration
// Run: SELECT create_hypertable('working_capital_metrics', by_range('metric_date', INTERVAL '1 month'));
model WorkingCapitalMetric {
  id          String   @id @default(uuid()) @db.Uuid
  companyId   String   @map("company_id") @db.Uuid
  metricDate  DateTime @map("metric_date") @db.Timestamptz()
  dso         Decimal? @db.Decimal(10, 2) // Days Sales Outstanding
  dpo         Decimal? @db.Decimal(10, 2) // Days Payable Outstanding
  ccc         Decimal? @db.Decimal(10, 2) // Cash Conversion Cycle
  arBalance   BigInt?  @map("ar_balance") // in cents
  apBalance   BigInt?  @map("ap_balance") // in cents
  cashBalance BigInt?  @map("cash_balance") // in cents
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, metricDate])
  @@index([metricDate(sort: Desc)])
  @@map("working_capital_metrics")
}

// =============================================================================
// AUDIT LOG
// =============================================================================

model AuditLog {
  id           String   @id @default(uuid()) @db.Uuid
  companyId    String?  @map("company_id") @db.Uuid
  userId       String?  @map("user_id") @db.Uuid
  action       String   @db.VarChar(100)
  resourceType String   @map("resource_type") @db.VarChar(50)
  resourceId   String?  @map("resource_id") @db.Uuid
  ipAddress    String?  @map("ip_address") @db.Inet
  userAgent    String?  @map("user_agent") @db.Text
  oldValues    Json?    @map("old_values")
  newValues    Json?    @map("new_values")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz()

  // Relations
  company Company? @relation(fields: [companyId], references: [id], onDelete: SetNull)
  user    User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([companyId, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
  @@map("audit_logs")
}
